// interfaces нужны для создания некое типа, который служит для объектов или классов, где мы указываем какие поля, функции и какие вообще элементы должны присутствовать у этих объектов
// interfaces ни во что не компилируются
// для того что бы завести interface используем ключевое слово interface, затем указываем его название, в скобках описываем его параметры
// параметры указываются с типами (указали параметр id с типом string, + указали что это поле только для чтения readonly)
// знак ? после названия параметра, указывает что этот параметр НЕ ОБЯЗАТЕЛЬНЫЙ
// в параметрах можно указывать и объекты (size)
interface Rect {
  readonly id: string
  color?: string
  size: {
    width: number
    height: number
  }
}

// теперь можно создать разлчные объекты которые будут являться типом Rect
const rect1: Rect = {
  id: 'squre',
  size: {
    width: 5,
    height: 10,
  },
  color: '#ccc',
}

// создадим второй объект без поля color (тоже будет крректно)
const rect2: Rect = {
  id: 'squre2',
  size: {
    width: 10,
    height: 20,
  },
}
// поле color также можно назначить ниже просто прописав
rect2.color = 'gold'

// с объектами и интерфейсами можно также указывать к какому типу будет относиться объект
// создадим по умолчанию пустой объект, и строго укажем ему тип Rect (as Rect)
const rect3 = {} as Rect
// альтернативная старая запись указания типа объекта (<Rect>)
const rect4 = <Rect>{}

// ========================================

// Наследование интерфейсов

// При создании новых интерфейсов мы можем наследоваться от уже имеющихся и допустим дополнять их своими дополнительными полями
// интерфейс RectWithArea будет наследоваться от нашего интерфейса Rect
// добавим в него новые поля к примеру функцию для расчета площади
// getArea: () => - запись стрелочной функции после двоеточия, является также указанием типа для getArea, (т.е. мы говорим что это будет функция), а дальше указываем тип данных который будет возвращен этой функцией - number
interface RectWithArea extends Rect {
  getArea: () => number
}
// после создадим новый объект, указав в типе наш новый интерфейс, который в свою очередь наследуется от Rect, и укажем все обязательный поля из обоих интерфейсов
const rect5: RectWithArea = {
  id: '123',
  size: {
    width: 30,
    height: 60,
  },
  // ... : number... - это явное указание что возвращает ф-я
  getArea(): number {
    return this.size.width * this.size.height
  },
}

// ========================================

// Взаимодействие interfaces с КЛАССАМИ
// зачастую название интерфейсов начинают с большой буквы I
interface IClock {
  time: Date // поле time с типом Date
  setTime(date: Date): void // класс который будет имплементироваться от данного интерфейса, он должен будет реализовать метод setTime(), КОТОРЫЙ БУДЕТ ПРИНИМАТЬ НЕКУЮ date с типом Date
}
// теперь создадим какой-нибудь класс, к примеру Clock
// и для того чтобы TS понял что данный class имплементируется от интерфейса IClock и должен реализовать его методы
// пропишем ключевое слово implements и название интерфейса
// внутри реализовываем необходимые поля
class Clock implements IClock {
  time: Date = new Date() // = new Date() - указываем значение по умолчанию
  setTime(date: Date): void {
    this.time = date
  }
}

// ========================================

// Когда необходимо создать interface для объекта у которого будет множество динамических ключей
// создадим переменную css - это будет объект со свойствами

const css: Styles = {
  border: '1px solid black',
  marginTop: '2px',
  borderRadius: '5px',
}
// безусловно мы можем создать интерфейс для данного объекта, назовем его Styles
interface Styles {
  [key: string]: string
  // border: string // и т.д.
}
// но мы не можем перечислять вообще все css свойства, это будет не эфективно
// для таких ситуаций можно указать специальный синтаксис в [] скобках можно указать тип ключа через ключевое слово key и указываем его тип  [key: string],а в значении указываем тип string - [key: string]: string
